From 77e422fc78a6dbc6fd0e96010e0df30f4d376e08 Mon Sep 17 00:00:00 2001
From: Dmitrii Pichulin <deem@deem.ru>
Date: Fri, 5 Mar 2021 01:59:16 -0800
Subject: [PATCH] chromium GOSTSSL

---
 chrome/app/app-entitlements.plist             |   6 +
 chrome/app/theme/chromium/BRANDING            |   2 +-
 .../native_process_launcher_posix.cc          |  12 ++
 .../resources/local_ntp/local_ntp.html        |   4 +-
 .../browser/resources/local_ntp/local_ntp.js  |   2 +-
 chrome/browser/resources/new_tab_page/app.js  |   4 +-
 .../browser/resources/new_tab_page/logo.html  |   5 +-
 chrome/browser/search/local_ntp_source.cc     |   7 ++
 .../chromium-browser/chromium-browser.info    |  10 +-
 .../installer/linux/rpm/chrome.spec.template  |   4 +
 .../app_shim/certificate_viewer.mm            |  46 +++++++
 content/browser/BUILD.gn                      |   8 ++
 .../direct_sockets_service_impl.cc            |   2 +
 content/browser/storage_partition_impl.cc     |   9 ++
 content/common/user_agent.cc                  |   2 +-
 net/base/net_error_list.h                     |   5 +
 net/cert/cert_verify_proc.cc                  |  23 ++++
 net/http/http_network_transaction.cc          |   9 ++
 net/socket/socket.h                           |   4 +
 net/socket/ssl_client_socket.cc               |   9 ++
 net/socket/ssl_client_socket.h                |   4 +
 net/socket/ssl_client_socket_impl.cc          | 112 ++++++++++++++++++
 net/socket/ssl_client_socket_impl.h           |   3 +
 net/spdy/spdy_session.cc                      |   5 +
 net/ssl/client_cert_store_mac.cc              |  31 +++++
 net/ssl/client_cert_store_nss.cc              |  33 ++++++
 net/ssl/client_cert_store_win.cc              |  32 +++++
 net/ssl/openssl_ssl_util.cc                   |   4 +
 net/ssl/ssl_cipher_suite_names.cc             |  36 ++++++
 net/ssl/ssl_platform_key_util.cc              |  21 ++++
 net/ssl/ssl_platform_key_util.h               |   7 ++
 sandbox/policy/mac/common.sb                  |  16 +++
 sandbox/win/src/process_mitigations.cc        |   4 +
 .../blink/renderer/core/frame/local_frame.cc  |   5 +
 .../blink/renderer/core/frame/local_frame.h   |   7 +-
 .../renderer/core/frame/reporting_context.cc  |   9 ++
 .../renderer/core/frame/reporting_context.h   |   7 +-
 third_party/boringssl/BUILD.generated.gni     |   2 +
 38 files changed, 490 insertions(+), 21 deletions(-)

diff --git a/chrome/app/app-entitlements.plist b/chrome/app/app-entitlements.plist
index 522375410823..aae9bd8eba5d 100644
--- a/chrome/app/app-entitlements.plist
+++ b/chrome/app/app-entitlements.plist
@@ -14,5 +14,11 @@
 	<true/>
 	<key>com.apple.security.personal-information.location</key>
 	<true/>
+	<key>com.apple.security.smartcard</key>
+	<true/>
+	<key>com.apple.security.cs.allow-unsigned-executable-memory</key>
+	<true/>
+	<key>com.apple.security.cs.disable-library-validation</key>
+	<true/>
 </dict>
 </plist>
diff --git a/chrome/app/theme/chromium/BRANDING b/chrome/app/theme/chromium/BRANDING
index a2020a0b6f92..1afa567fd346 100644
--- a/chrome/app/theme/chromium/BRANDING
+++ b/chrome/app/theme/chromium/BRANDING
@@ -5,6 +5,6 @@ PRODUCT_SHORTNAME=Chromium
 PRODUCT_INSTALLER_FULLNAME=Chromium Installer
 PRODUCT_INSTALLER_SHORTNAME=Chromium Installer
 COPYRIGHT=Copyright 2020 The Chromium Authors. All rights reserved.
-MAC_BUNDLE_ID=org.chromium.Chromium
+MAC_BUNDLE_ID=ru.cryptopro.chromium-gost
 MAC_CREATOR_CODE=Cr24
 MAC_TEAM_ID=
diff --git a/chrome/browser/extensions/api/messaging/native_process_launcher_posix.cc b/chrome/browser/extensions/api/messaging/native_process_launcher_posix.cc
index 27398beca002..ca11dc56aa78 100644
--- a/chrome/browser/extensions/api/messaging/native_process_launcher_posix.cc
+++ b/chrome/browser/extensions/api/messaging/native_process_launcher_posix.cc
@@ -43,6 +43,18 @@ base::FilePath NativeProcessLauncher::FindManifest(
     result = FindManifestInDir(chrome::DIR_USER_NATIVE_MESSAGING, host_name);
   if (result.empty())
     result = FindManifestInDir(chrome::DIR_NATIVE_MESSAGING, host_name);
+#ifndef NO_GOSTSSL
+  if (result.empty()) {
+#if defined(__APPLE__)
+    base::FilePath base_path = base::FilePath(FILE_PATH_LITERAL("/Library/Google/Chrome/NativeMessagingHosts"));
+#else
+    base::FilePath base_path = base::FilePath(FILE_PATH_LITERAL("/etc/opt/chrome/native-messaging-hosts"));
+#endif
+    base::FilePath path = base_path.Append(host_name + ".json");
+    if (base::PathExists(path))
+      result = path;
+  }
+#endif // GOSTSSL
 
   if (result.empty())
     *error_message = "Can't find native messaging host " + host_name;
diff --git a/chrome/browser/resources/local_ntp/local_ntp.html b/chrome/browser/resources/local_ntp/local_ntp.html
index 1608f7574403..52498d5b36d1 100644
--- a/chrome/browser/resources/local_ntp/local_ntp.html
+++ b/chrome/browser/resources/local_ntp/local_ntp.html
@@ -41,9 +41,9 @@
   <div id="ntp-contents">
     <div id="logo">
       <!-- The logo that is displayed in the absence of a doodle. -->
-      <div id="logo-default" title="Google"></div>
+      <div id="logo-default" title="Chromium GOST"></div>
       <!-- Logo displayed when theme prevents doodles. Doesn't fade. -->
-      <div id="logo-non-white" title="Google"></div>
+      <div id="logo-non-white" title="Chromium GOST"></div>
       <!-- A doodle, if any: its link and image. -->
       <div id="logo-doodle">
         <div id="logo-doodle-container">
diff --git a/chrome/browser/resources/local_ntp/local_ntp.js b/chrome/browser/resources/local_ntp/local_ntp.js
index d9d58e1ddef9..1e7e6f26f029 100644
--- a/chrome/browser/resources/local_ntp/local_ntp.js
+++ b/chrome/browser/resources/local_ntp/local_ntp.js
@@ -1949,7 +1949,7 @@ function renderTheme() {
   // Dark mode uses a white Google logo.
   const useWhiteLogo =
       theme.alternateLogo || (theme.usingDefaultTheme && isDarkModeEnabled);
-  document.body.classList.toggle(CLASSES.ALTERNATE_LOGO, useWhiteLogo);
+  document.body.classList.toggle(CLASSES.ALTERNATE_LOGO, false);
 
   if (theme.logoColor) {
     document.body.style.setProperty(
diff --git a/chrome/browser/resources/new_tab_page/app.js b/chrome/browser/resources/new_tab_page/app.js
index dc2539582c27..1aa2e9e3c2d1 100644
--- a/chrome/browser/resources/new_tab_page/app.js
+++ b/chrome/browser/resources/new_tab_page/app.js
@@ -709,9 +709,7 @@ class AppElement extends PolymerElement {
    * @private
    */
   computeDoodleAllowed_() {
-    return loadTimeData.getBoolean('themeModeDoodlesEnabled') ||
-        !this.showBackgroundImage_ && this.theme_ && this.theme_.isDefault &&
-        !this.theme_.isDark;
+    return false;
   }
 
   /**
diff --git a/chrome/browser/resources/new_tab_page/logo.html b/chrome/browser/resources/new_tab_page/logo.html
index 02ab0a21c9da..10667422c1ee 100644
--- a/chrome/browser/resources/new_tab_page/logo.html
+++ b/chrome/browser/resources/new_tab_page/logo.html
@@ -19,10 +19,7 @@
   }
 
   :host([single-colored]) #logo {
-    -webkit-mask-image: url(./icons/google_logo.svg);
-    -webkit-mask-repeat: no-repeat;
-    -webkit-mask-size: 100%;
-    background-color: var(--ntp-logo-color);
+    background-image: url(./icons/google_logo.svg);
   }
 
   :host(:not([single-colored])) #logo {
diff --git a/chrome/browser/search/local_ntp_source.cc b/chrome/browser/search/local_ntp_source.cc
index 9b2ac5089845..3be010bed10d 100644
--- a/chrome/browser/search/local_ntp_source.cc
+++ b/chrome/browser/search/local_ntp_source.cc
@@ -849,6 +849,13 @@ void LocalNtpSource::StartDataRequest(
     return;
   }
 
+#ifndef NO_GOSTSSL
+  if( stripped_path == kPromoScriptFilename || stripped_path == kDoodleScriptFilename ) {
+    std::move(callback).Run(nullptr);
+    return;
+  }
+#endif /* NO_GOSTSSL */
+
   if (stripped_path == chrome::kChromeSearchLocalNtpBackgroundFilename) {
     base::ThreadPool::PostTaskAndReplyWithResult(
         FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
diff --git a/chrome/installer/linux/common/chromium-browser/chromium-browser.info b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
index 6f67b06166f0..997d45b6af45 100644
--- a/chrome/installer/linux/common/chromium-browser/chromium-browser.info
+++ b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
@@ -6,7 +6,7 @@
 # chromium-browser packages for various platforms.
 
 # Base name of the package.
-PACKAGE="chromium-browser"
+PACKAGE="chromium-gost"
 
 # Base name of the snap package
 SNAPNAME="chromium"
@@ -15,16 +15,16 @@ SNAPNAME="chromium"
 PROGNAME=chrome
 
 # Base directory for package installation.
-INSTALLDIR=/opt/chromium.org/chromium
+INSTALLDIR=/opt/chromium-gost
 
 # Display string for desktop menu/icon.
-MENUNAME="Chromium Web Browser"
+MENUNAME="chromium-gost"
 
 # Brief package description.
-SHORTDESC="The web browser from Chromium.org"
+SHORTDESC="Chromium browser with GOST cryptography support"
 
 # Detailed package description.
-FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier."
+FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier. This version supports GOST cryptography in TLS-connections."
 
 # Package maintainer information.
 # TODO(mmoss) Setup a mailbox for this address
diff --git a/chrome/installer/linux/rpm/chrome.spec.template b/chrome/installer/linux/rpm/chrome.spec.template
index c755e4cea220..e7cfec11ec84 100644
--- a/chrome/installer/linux/rpm/chrome.spec.template
+++ b/chrome/installer/linux/rpm/chrome.spec.template
@@ -122,6 +122,8 @@ add_nss_symlinks
 
 remove_udev_symlinks
 
+if false; then
+
 DEFAULTS_FILE="/etc/default/@@PACKAGE@@"
 if [ ! -e "$DEFAULTS_FILE" ]; then
   echo 'repo_add_once="true"' > "$DEFAULTS_FILE"
@@ -145,6 +147,8 @@ if [ "$repo_add_once" = "true" ]; then
   done
 fi
 
+fi
+
 CHANNEL=@@CHANNEL@@
 case $CHANNEL in
   stable )
diff --git a/components/remote_cocoa/app_shim/certificate_viewer.mm b/components/remote_cocoa/app_shim/certificate_viewer.mm
index 0c12e8bda385..c071d69f7a7b 100644
--- a/components/remote_cocoa/app_shim/certificate_viewer.mm
+++ b/components/remote_cocoa/app_shim/certificate_viewer.mm
@@ -14,10 +14,56 @@
 #include "net/cert/x509_util_ios_and_mac.h"
 #include "net/cert/x509_util_mac.h"
 
+#ifndef NO_GOSTSSL
+extern "C" {
+#include "third_party/boringssl/src/include/openssl/pool.h"
+void gostssl_isgostcerthook( void * cert, int size, int * is_gost );
+char gostssl_certificate_info( const char * cert, size_t size, const char ** info, size_t * len );
+}
+#endif // GOSTSSL
+
 namespace remote_cocoa {
 
 void ShowCertificateViewerForWindow(NSWindow* owning_window,
                                     net::X509Certificate* certificate) {
+#ifndef NO_GOSTSSL
+    int is_gost = 0;
+    {
+        const uint8_t * gostcert = CRYPTO_BUFFER_data( certificate->cert_buffer() );
+        size_t gostcertlen =  CRYPTO_BUFFER_len( certificate->cert_buffer() );
+        gostssl_isgostcerthook( (void *)gostcert, gostcertlen, &is_gost );
+    }
+
+    if( is_gost == 1 )
+    {
+        const char * info;
+        size_t infoLen;
+        NSAttributedString * certinfo;
+
+        const char * gostcert = (const char *)CRYPTO_BUFFER_data( certificate->cert_buffer() );
+        size_t gostcertlen =  CRYPTO_BUFFER_len( certificate->cert_buffer() );
+        if( !gostssl_certificate_info( gostcert, gostcertlen, &info, &infoLen ) )
+            certinfo = [[NSAttributedString alloc] initWithString:@"(Не удалось получить информацию о сертификате)"];
+        else
+            certinfo = [[NSAttributedString alloc] initWithHTML:[NSData dataWithBytes:info length:infoLen] documentAttributes:nil];
+
+        return dispatch_async( dispatch_get_main_queue(), ^
+        {
+            NSAlert * alert = [[NSAlert alloc] init];
+            NSTextView * accessory = [[NSTextView alloc] initWithFrame:NSMakeRect( 0, 0, 600, 400 )];
+            [accessory insertText:certinfo replacementRange:NSMakeRange( 0, 0 )];
+            [accessory setEditable:NO];
+            [accessory setDrawsBackground:NO];
+            accessory.textColor = [NSColor controlTextColor];
+
+            [alert setMessageText:@"Информация о сертификате сайта"];
+            [alert setAccessoryView:accessory];
+            [alert setAlertStyle:NSAlertStyleInformational];
+            [alert beginSheetModalForWindow:owning_window completionHandler:nil];
+        } );
+    }
+#endif // GOSTSSL
+
   base::ScopedCFTypeRef<CFArrayRef> cert_chain(
       net::x509_util::CreateSecCertificateArrayForX509Certificate(certificate));
   if (!cert_chain)
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 266fd660ec0c..606921c2d7b9 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2804,6 +2804,14 @@ source_set("browser") {
       "net/reporting_service_proxy.h",
     ]
   }
+  else {
+    sources += [
+      "net/cross_origin_embedder_policy_reporter.cc",
+      "net/cross_origin_embedder_policy_reporter.h",
+      "net/cross_origin_opener_policy_reporter.cc",
+      "net/cross_origin_opener_policy_reporter.h",
+    ]
+  }
 
   if (use_viz_devtools) {
     sources += [
diff --git a/content/browser/direct_sockets/direct_sockets_service_impl.cc b/content/browser/direct_sockets/direct_sockets_service_impl.cc
index 5ef284bdf68f..01c6cfd822c0 100644
--- a/content/browser/direct_sockets/direct_sockets_service_impl.cc
+++ b/content/browser/direct_sockets/direct_sockets_service_impl.cc
@@ -53,10 +53,12 @@ base::Optional<net::IPEndPoint> GetLocalAddr(
   return local_addr;
 }
 
+#if BUILDFLAG(ENABLE_MDNS)
 bool ResemblesMulticastDNSName(const std::string& hostname) {
   return base::EndsWith(hostname, ".local") ||
          base::EndsWith(hostname, ".local.");
 }
+#endif  // !BUILDFLAG(ENABLE_MDNS)
 
 }  // namespace
 
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index c28ce91036fb..4e192811c825 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -124,6 +124,10 @@
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // defined(OS_ANDROID)
 
+#ifndef NO_GOSTSSL
+#include "net/ssl/ssl_platform_key_util.h"
+#endif // GOSTSSL
+
 #if BUILDFLAG(ENABLE_PLUGINS)
 #include "content/browser/plugin_private_storage_helper.h"
 #endif  // BUILDFLAG(ENABLE_PLUGINS)
@@ -613,6 +617,11 @@ class SSLClientAuthDelegate : public SSLClientAuthHandler::Delegate {
       scoped_refptr<net::X509Certificate> cert,
       scoped_refptr<net::SSLPrivateKey> private_key) override {
     DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#ifndef NO_GOSTSSL
+    if (cert && !private_key) {
+        private_key = net::GetEmptyPrivateKey();
+    }
+#endif // GOSTSSL
     DCHECK((cert && private_key) || (!cert && !private_key));
 
     if (cert && private_key) {
diff --git a/content/common/user_agent.cc b/content/common/user_agent.cc
index cb27a7d6ef92..9f8c069869c3 100644
--- a/content/common/user_agent.cc
+++ b/content/common/user_agent.cc
@@ -298,7 +298,7 @@ std::string BuildUserAgentFromOSAndProduct(const std::string& os_info,
   std::string user_agent;
   base::StringAppendF(
       &user_agent,
-      "Mozilla/5.0 (%s) AppleWebKit/%d.%d (KHTML, like Gecko) %s Safari/%d.%d",
+      "Mozilla/5.0 (%s) AppleWebKit/%d.%d (KHTML, like Gecko) %s Safari/%d.%d (Chromium GOST)",
       os_info.c_str(),
       WEBKIT_VERSION_MAJOR,
       WEBKIT_VERSION_MINOR,
diff --git a/net/base/net_error_list.h b/net/base/net_error_list.h
index c18e34fbd7b8..6ce21e603aa2 100644
--- a/net/base/net_error_list.h
+++ b/net/base/net_error_list.h
@@ -22,6 +22,11 @@
 //   700-799 Certificate manager errors
 //   800-899 DNS resolver errors
 
+#ifndef NO_GOSTSSL
+//   3000-3099 GOSTSSL
+NET_ERROR(TLS_GOST_REQUIRED, -3072)
+#endif // GOSTSSL
+
 // An asynchronous IO operation is not yet complete.  This usually does not
 // indicate a fatal error.  Typically this error will be generated as a
 // notification to wait for some external notification that the IO operation
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index 6135c24fe81b..45504adba63e 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -523,6 +523,12 @@ scoped_refptr<CertVerifyProc> CertVerifyProc::CreateBuiltinVerifyProc(
 
 CertVerifyProc::CertVerifyProc() {}
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_isgostcerthook( void * cert, int size, int * is_gost );
+}
+#endif // GOSTSSL
+
 CertVerifyProc::~CertVerifyProc() = default;
 
 int CertVerifyProc::Verify(X509Certificate* cert,
@@ -555,6 +561,23 @@ int CertVerifyProc::Verify(X509Certificate* cert,
       VerifyInternal(cert, hostname, ocsp_response, sct_list, flags, crl_set,
                      additional_trust_anchors, verify_result, net_log);
 
+#ifndef NO_GOSTSSL
+  int is_gost = 0;
+  {
+      {
+          const uint8_t * gostcert = CRYPTO_BUFFER_data( cert->cert_buffer() );
+          size_t gostcertlen =  CRYPTO_BUFFER_len( cert->cert_buffer() );
+          gostssl_isgostcerthook( (void *)gostcert, gostcertlen, &is_gost );
+      }
+  }
+
+  if( is_gost == 1 )
+  {
+      // TODO: we can check for weak GOST algos
+  }
+  else
+#endif // GOSTSSL
+
   // Check for mismatched signature algorithms and unknown signature algorithms
   // in the chain. Also fills in the has_* booleans for the digest algorithms
   // present in the chain.
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index 1a624bfe461f..39c4944407ae 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -1507,6 +1507,15 @@ int HttpNetworkTransaction::HandleSSLClientAuthError(int error) {
       }
     }
   }
+
+#ifndef NO_GOSTSSL
+  if( error == ERR_TLS_GOST_REQUIRED )
+  {
+    ResetConnectionAndRequestForResend();
+    return OK;
+  }
+#endif // GOSTSSL
+
   return error;
 }
 
diff --git a/net/socket/socket.h b/net/socket/socket.h
index beecf2325a15..7f3f0488afdf 100644
--- a/net/socket/socket.h
+++ b/net/socket/socket.h
@@ -21,6 +21,10 @@ class IOBuffer;
 // Represents a read/write socket.
 class NET_EXPORT Socket {
  public:
+#ifndef NO_GOSTSSL
+  virtual int IsMSSPI() { return 0; }
+#endif // GOSTSSL
+
   Socket();
   virtual ~Socket();
 
diff --git a/net/socket/ssl_client_socket.cc b/net/socket/ssl_client_socket.cc
index fcfc88b342ae..318e2278dfd3 100644
--- a/net/socket/ssl_client_socket.cc
+++ b/net/socket/ssl_client_socket.cc
@@ -12,6 +12,10 @@
 #include "net/ssl/ssl_client_session_cache.h"
 #include "net/ssl/ssl_key_logger.h"
 
+#ifndef NO_GOSTSSL
+#include "base/atomic_sequence_num.h"
+#endif /* NO_GOSTSSL */
+
 namespace net {
 
 SSLClientSocket::SSLClientSocket()
@@ -68,6 +72,11 @@ SSLClientContext::SSLClientContext(
     ssl_config_service_->AddObserver(this);
   }
   CertDatabase::GetInstance()->AddObserver(this);
+
+#ifndef NO_GOSTSSL
+  static base::AtomicSequenceNumber g_seqnum;
+  seqnum_ = g_seqnum.GetNext();
+#endif /* NO_GOSTSSL */
 }
 
 SSLClientContext::~SSLClientContext() {
diff --git a/net/socket/ssl_client_socket.h b/net/socket/ssl_client_socket.h
index 0f0fe9a36df1..5c89b9280901 100644
--- a/net/socket/ssl_client_socket.h
+++ b/net/socket/ssl_client_socket.h
@@ -172,6 +172,10 @@ class NET_EXPORT SSLClientContext : public SSLConfigService::Observer,
   // CertDatabase::Observer:
   void OnCertDBChanged() override;
 
+#ifndef NO_GOSTSSL
+  int seqnum_;
+#endif /* NO_GOSTSSL */
+
  private:
   void NotifySSLConfigChanged(bool is_cert_database_change);
   void NotifySSLConfigForServerChanged(const HostPortPair& server);
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
index 5c5c3e34c709..1fbeea5ee3b5 100644
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -417,6 +417,18 @@ int SSLClientSocketImpl::ExportKeyingMaterial(const base::StringPiece& label,
   return OK;
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_newsession( SSL * s, const void * cachestring, size_t len, const void * cert, int size );
+void gostssl_certhook( void * cert, int size );
+void gostssl_verifyhook( void * s, const char * host, unsigned * is_gost );
+int gostssl_is_msspi( SSL * s );
+}
+int SSLClientSocketImpl::IsMSSPI() {
+  return gostssl_is_msspi( ssl_.get() );
+}
+#endif // GOSTSSL
+
 int SSLClientSocketImpl::Connect(CompletionOnceCallback callback) {
   // Although StreamSocket does allow calling Connect() after Disconnect(),
   // this has never worked for layered sockets. CHECK to detect any consumers
@@ -435,6 +447,18 @@ int SSLClientSocketImpl::Connect(CompletionOnceCallback callback) {
     return rv;
   }
 
+#ifndef NO_GOSTSSL
+  {
+    const void * cert = NULL;
+    int len = 0;
+    if (client_cert_.get()) {
+      cert = (const void *)CRYPTO_BUFFER_data(client_cert_.get()->cert_buffer());
+      len = (int)CRYPTO_BUFFER_len(client_cert_.get()->cert_buffer());
+    }
+    gostssl_newsession( ssl_.get(), &context_->seqnum_, sizeof( context_->seqnum_ ), cert, len );
+  }
+#endif // GOSTSSL
+
   // Set SSL to client mode. Handshake happens in the loop below.
   SSL_set_connect_state(ssl_.get());
 
@@ -1091,6 +1115,82 @@ ssl_verify_result_t SSLClientSocketImpl::VerifyCert() {
 
   start_cert_verification_time_ = base::TimeTicks::Now();
 
+#ifndef NO_GOSTSSL
+#ifndef TRUST_E_CERT_SIGNATURE
+#define TRUST_E_CERT_SIGNATURE          0x80096004L
+#define CRYPT_E_REVOKED                 0x80092010L
+#define CERT_E_UNTRUSTEDROOT            0x800B0109L
+#define CERT_E_UNTRUSTEDTESTROOT        0x800B010DL
+#define CERT_E_REVOCATION_FAILURE       0x800B010EL
+#define CERT_E_EXPIRED                  0x800B0101L
+#define CERT_E_INVALID_NAME             0x800B0114L
+#define CERT_E_CN_NO_MATCH              0x800B010FL
+#define CERT_E_VALIDITYPERIODNESTING    0x800B0102L
+#define CRYPT_E_NO_REVOCATION_CHECK     0x80092012L
+#define CRYPT_E_REVOCATION_OFFLINE      0x80092013L
+#define CERT_E_CHAINING                 0x800B010AL
+#endif
+
+  {
+    {
+      unsigned gost_status;
+      gostssl_verifyhook( (void*)ssl_.get(), host_and_port_.host().c_str(), &gost_status );
+      if (gost_status) {
+        int gost_rv = OK;
+
+        switch (gost_status) {
+          case 1:
+            break;
+          case CERT_E_CN_NO_MATCH:
+          case CERT_E_INVALID_NAME:
+            gost_rv = ERR_CERT_COMMON_NAME_INVALID;
+            break;
+          case CERT_E_UNTRUSTEDROOT:
+          case TRUST_E_CERT_SIGNATURE:
+          case CERT_E_UNTRUSTEDTESTROOT:
+          case CERT_E_CHAINING:
+            gost_rv = ERR_CERT_AUTHORITY_INVALID;
+            break;
+          case CERT_E_EXPIRED:
+          case CERT_E_VALIDITYPERIODNESTING:
+            gost_rv = ERR_CERT_DATE_INVALID;
+            break;
+          case CRYPT_E_NO_REVOCATION_CHECK:
+          case CERT_E_REVOCATION_FAILURE:
+            gost_rv = ERR_CERT_NO_REVOCATION_MECHANISM;
+            break;
+          case CRYPT_E_REVOCATION_OFFLINE:
+            gost_rv = ERR_CERT_UNABLE_TO_CHECK_REVOCATION;
+            break;
+          case CRYPT_E_REVOKED:
+            gost_rv = ERR_CERT_REVOKED;
+            break;
+          default:
+            gost_rv = ERR_CERT_INVALID;
+            break;
+        }
+
+        server_cert_verify_result_.Reset();
+        server_cert_verify_result_.verified_cert = server_cert_;
+
+        if( gost_rv == OK )
+        {
+          cert_verification_result_ = OK;
+        }
+        else
+        {
+          server_cert_verify_result_.cert_status =
+              MapNetErrorToCertStatus(gost_rv);
+          cert_verification_result_ = gost_rv;
+          OpenSSLPutNetError(FROM_HERE, gost_rv);
+        }
+
+        return gost_rv == OK ? ssl_verify_ok : ssl_verify_invalid;
+      }
+    }
+  }
+#endif // GOSTSSL
+
   const uint8_t* ocsp_response_raw;
   size_t ocsp_response_len;
   SSL_get0_ocsp_response(ssl_.get(), &ocsp_response_raw, &ocsp_response_len);
@@ -1592,6 +1692,18 @@ int SSLClientSocketImpl::ClientCertRequestCallback(SSL* ssl) {
     return -1;
   }
 
+#ifndef NO_GOSTSSL
+  if (client_cert_.get()) {
+    {
+      const uint8_t* cert =
+          CRYPTO_BUFFER_data(client_cert_.get()->cert_buffer());
+      size_t len =
+          CRYPTO_BUFFER_len(client_cert_.get()->cert_buffer());
+      gostssl_certhook( (void*)cert, len );
+    }
+  }
+#endif // GOSTSSL
+
   // Second pass: a client certificate should have been selected.
   if (client_cert_.get()) {
     if (!client_private_key_) {
diff --git a/net/socket/ssl_client_socket_impl.h b/net/socket/ssl_client_socket_impl.h
index 31a2e664579d..628ae55d1c4b 100644
--- a/net/socket/ssl_client_socket_impl.h
+++ b/net/socket/ssl_client_socket_impl.h
@@ -50,6 +50,9 @@ class X509Certificate;
 class SSLClientSocketImpl : public SSLClientSocket,
                             public SocketBIOAdapter::Delegate {
  public:
+#ifndef NO_GOSTSSL
+  int IsMSSPI() override;
+#endif // GOSTSSL
   // Takes ownership of |stream_socket|, which may already be connected.
   // The given hostname will be compared with the name(s) in the server's
   // certificate during the SSL handshake.  |ssl_config| specifies the SSL
diff --git a/net/spdy/spdy_session.cc b/net/spdy/spdy_session.cc
index 61190919dada..33f065fed0ac 100644
--- a/net/spdy/spdy_session.cc
+++ b/net/spdy/spdy_session.cc
@@ -1611,6 +1611,11 @@ void SpdySession::RemovePooledAlias(const SpdySessionKey& alias_key) {
 }
 
 bool SpdySession::HasAcceptableTransportSecurity() const {
+#ifndef NO_GOSTSSL
+  // MSSPI is acceptable
+  if( socket_->IsMSSPI() )
+    return true;
+#endif // GOSTSSL
   SSLInfo ssl_info;
   CHECK(GetSSLInfo(&ssl_info));
 
diff --git a/net/ssl/client_cert_store_mac.cc b/net/ssl/client_cert_store_mac.cc
index 7d97f1d09041..a49a46357295 100644
--- a/net/ssl/client_cert_store_mac.cc
+++ b/net/ssl/client_cert_store_mac.cc
@@ -295,6 +295,12 @@ void AddIdentity(ScopedCFTypeRef<SecIdentityRef> sec_identity,
   }
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 ClientCertIdentityList GetClientCertsOnBackgroundThread(
     const SSLCertRequestInfo& request) {
   std::string server_domain = request.host_and_port.host();
@@ -385,6 +391,31 @@ ClientCertIdentityList GetClientCertsOnBackgroundThread(
   GetClientCertsImpl(std::move(preferred_identity),
                      std::move(regular_identities), request, true,
                      &selected_identities);
+
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( certs[i], lens[i] );
+        if( !cert.get() )
+          continue;
+        ScopedCFTypeRef<SecIdentityRef> sec_identity;
+        selected_identities.push_back( std::make_unique<ClientCertIdentityMac>( cert, std::move( sec_identity ) ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   return selected_identities;
 }
 
diff --git a/net/ssl/client_cert_store_nss.cc b/net/ssl/client_cert_store_nss.cc
index 9ef425caaa56..2795c6d52efc 100644
--- a/net/ssl/client_cert_store_nss.cc
+++ b/net/ssl/client_cert_store_nss.cc
@@ -145,6 +145,12 @@ void ClientCertStoreNSS::FilterCertsOnWorkerThread(
   std::sort(identities->begin(), identities->end(), ClientCertIdentitySorter());
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 ClientCertIdentityList ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
     scoped_refptr<crypto::CryptoModuleBlockingPasswordDelegate>
         password_delegate,
@@ -159,6 +165,33 @@ ClientCertIdentityList ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
   GetPlatformCertsOnWorkerThread(std::move(password_delegate), CertFilter(),
                                  &selected_identities);
   FilterCertsOnWorkerThread(&selected_identities, *request);
+
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( certs[i], lens[i] );
+        if( !cert.get() )
+          continue;
+        ScopedCERTCertificate nss_cert = x509_util::CreateCERTCertificateFromBytes( (uint8_t *)certs[i], lens[i] );
+        if( !nss_cert.get() )
+          continue;
+        selected_identities.push_back( std::make_unique<ClientCertIdentityNSS>( cert, x509_util::DupCERTCertificate( nss_cert.get() ), password_delegate ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   return selected_identities;
 }
 
diff --git a/net/ssl/client_cert_store_win.cc b/net/ssl/client_cert_store_win.cc
index 226d7efbbcc1..49befd45283e 100644
--- a/net/ssl/client_cert_store_win.cc
+++ b/net/ssl/client_cert_store_win.cc
@@ -107,6 +107,12 @@ static BOOL WINAPI ClientCertFindCallback(PCCERT_CONTEXT cert_context,
   return TRUE;
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 ClientCertIdentityList GetClientCertsImpl(HCERTSTORE cert_store,
                                           const SSLCertRequestInfo& request) {
   ClientCertIdentityList selected_identities;
@@ -208,6 +214,32 @@ ClientCertIdentityList GetClientCertsImpl(HCERTSTORE cert_store,
     }
   }
 
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( certs[i], lens[i] );
+        if( !cert.get() )
+          continue;
+        ScopedPCCERT_CONTEXT scoped_certctx;
+        PCCERT_CONTEXT certctx = CertCreateCertificateContext( X509_ASN_ENCODING, (BYTE *)certs[i], (DWORD)lens[i] );
+        scoped_certctx.reset(certctx);
+        selected_identities.push_back( std::make_unique<ClientCertIdentityWin>( std::move( cert ), std::move( scoped_certctx ), current_thread ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   std::sort(selected_identities.begin(), selected_identities.end(),
             ClientCertIdentitySorter());
   return selected_identities;
diff --git a/net/ssl/openssl_ssl_util.cc b/net/ssl/openssl_ssl_util.cc
index 585338617635..77a560bb4c7c 100644
--- a/net/ssl/openssl_ssl_util.cc
+++ b/net/ssl/openssl_ssl_util.cc
@@ -85,6 +85,10 @@ int MapOpenSSLErrorSSL(uint32_t error_code) {
     case SSL_R_TLSV1_ALERT_PROTOCOL_VERSION:
     case SSL_R_UNSUPPORTED_PROTOCOL:
       return ERR_SSL_VERSION_OR_CIPHER_MISMATCH;
+#ifndef NO_GOSTSSL
+    case SSL_R_TLS_GOST_REQUIRED:
+      return ERR_TLS_GOST_REQUIRED;
+#endif // GOSTSSL
     case SSL_R_SSLV3_ALERT_BAD_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED:
diff --git a/net/ssl/ssl_cipher_suite_names.cc b/net/ssl/ssl_cipher_suite_names.cc
index fb852b7d005d..c58e475b1f4c 100644
--- a/net/ssl/ssl_cipher_suite_names.cc
+++ b/net/ssl/ssl_cipher_suite_names.cc
@@ -66,6 +66,34 @@ void SSLCipherSuiteToStrings(const char** key_exchange_str,
   *is_aead = false;
   *is_tls13 = false;
 
+#ifndef NO_GOSTSSL
+  switch( cipher_suite )
+  {
+  case 0x0081: // GOST2001-GOST89-GOST89
+  case 0xff85: // GOST2012-GOST8912-GOST8912
+  case 0xc102: // TLS_GOSTR341112_256_WITH_28147_CNT_IMIT
+      *key_exchange_str = "GOST_R_3410_2001";
+      *cipher_str = "GOST_28147_CNT";
+      *mac_str = "GOST_28147_IMIT";
+      return;
+
+  case 0xc100: // TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC
+      *key_exchange_str = "GOST_R_3410_2012_512";
+      *cipher_str = "GOST_KUZNYECHIK_CTR";
+      *mac_str = "GOST_KUZNYECHIK_OMAC";
+      return;
+
+  case 0xc101: // TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC
+      *key_exchange_str = "GOST_R_3410_2001";
+      *cipher_str = "GOST_MAGMA_CTR";
+      *mac_str = "GOST_MAGMA_OMAC";
+      return;
+
+  default:
+      break;
+  }
+#endif // GOSTSSL
+
   const SSL_CIPHER* cipher = SSL_get_cipher_by_value(cipher_suite);
   if (!cipher)
     return;
@@ -179,6 +207,14 @@ int ObsoleteSSLStatus(int connection_status, uint16_t signature_algorithm) {
   obsolete_ssl |= ObsoleteSSLStatusForProtocol(ssl_version);
 
   uint16_t cipher_suite = SSLConnectionStatusToCipherSuite(connection_status);
+#ifndef NO_GOSTSSL
+  if( cipher_suite == 0xc102 /* TLS_GOSTR341112_256_WITH_28147_CNT_IMIT */ ||
+      cipher_suite == 0xc101 /* TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC */ ||
+      cipher_suite == 0xc100 /* TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC */ ||
+      cipher_suite == 0x0081 /* GOST2001-GOST89-GOST89 */ ||
+      cipher_suite == 0xff85 /* GOST2012-GOST8912-GOST8912 */ )
+    return OBSOLETE_SSL_NONE;
+#endif // GOSTSSL
   obsolete_ssl |= ObsoleteSSLStatusForCipherSuite(cipher_suite);
 
   obsolete_ssl |= ObsoleteSSLStatusForSignature(signature_algorithm);
diff --git a/net/ssl/ssl_platform_key_util.cc b/net/ssl/ssl_platform_key_util.cc
index 9baac3b2db27..512ae099ec7e 100644
--- a/net/ssl/ssl_platform_key_util.cc
+++ b/net/ssl/ssl_platform_key_util.cc
@@ -51,6 +51,27 @@ scoped_refptr<base::SingleThreadTaskRunner> GetSSLPlatformKeyTaskRunner() {
   return g_platform_key_task_runner.Get().task_runner();
 }
 
+#ifndef NO_GOSTSSL
+class SSLEmptyPrivateKey : public ThreadedSSLPrivateKey::Delegate {
+ public:
+  SSLEmptyPrivateKey() {}
+  ~SSLEmptyPrivateKey() override {}
+  std::string GetProviderName() override { return "EmptyPrivateKey"; }
+  std::vector<uint16_t> GetAlgorithmPreferences() override { return {}; }
+  Error Sign(uint16_t algorithm,
+             base::span<const uint8_t> input,
+             std::vector<uint8_t>* signature) override {
+    return ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+  }
+ private:
+  DISALLOW_COPY_AND_ASSIGN(SSLEmptyPrivateKey);
+};
+scoped_refptr<SSLPrivateKey> GetEmptyPrivateKey() {
+  return base::MakeRefCounted<ThreadedSSLPrivateKey>(
+      std::make_unique<SSLEmptyPrivateKey>(), GetSSLPlatformKeyTaskRunner());
+}
+#endif // GOSTSSL
+
 bssl::UniquePtr<EVP_PKEY> GetClientCertPublicKey(
     const X509Certificate* certificate) {
   crypto::OpenSSLErrStackTracer tracker(FROM_HERE);
diff --git a/net/ssl/ssl_platform_key_util.h b/net/ssl/ssl_platform_key_util.h
index 02729fecba76..a586e0c5e237 100644
--- a/net/ssl/ssl_platform_key_util.h
+++ b/net/ssl/ssl_platform_key_util.h
@@ -15,6 +15,9 @@
 #include "base/optional.h"
 #include "base/single_thread_task_runner.h"
 #include "net/base/net_export.h"
+#ifndef NO_GOSTSSL
+#include "net/ssl/threaded_ssl_private_key.h"
+#endif // GOSTSSL
 #include "third_party/boringssl/src/include/openssl/base.h"
 
 namespace net {
@@ -28,6 +31,10 @@ class X509Certificate;
 NET_EXPORT_PRIVATE scoped_refptr<base::SingleThreadTaskRunner>
 GetSSLPlatformKeyTaskRunner();
 
+#ifndef NO_GOSTSSL
+NET_EXPORT_PRIVATE scoped_refptr<SSLPrivateKey> GetEmptyPrivateKey();
+#endif // GOSTSSL
+
 // Returns the public key of |certificate| as an |EVP_PKEY| or nullptr on error.
 bssl::UniquePtr<EVP_PKEY> GetClientCertPublicKey(
     const X509Certificate* certificate);
diff --git a/sandbox/policy/mac/common.sb b/sandbox/policy/mac/common.sb
index 84c7e99b329e..8fa5d3c06b47 100644
--- a/sandbox/policy/mac/common.sb
+++ b/sandbox/policy/mac/common.sb
@@ -121,6 +121,22 @@
   (subpath "/usr/lib")
 )
 
+(allow file*
+  (subpath "/opt/cprocsp")
+  (subpath "/etc/opt/cprocsp")
+  (subpath "/var/opt/cprocsp")
+  (subpath "/private/etc/opt/cprocsp")
+  (subpath "/private/var/opt/cprocsp")
+  (subpath "/Applications/CryptoPro")
+  (subpath "/Library")
+)
+
+(allow mach-lookup
+  (global-name "com.apple.windowserver.active")
+  (global-name "com.apple.UNCUserNotification")
+  (global-name "com.apple.ctkpcscd")
+)
+
 ; Reads from /etc.
 ; This is read by CFPrefs calling getpwuid in a loop. libinfo then fails to
 ; contact any of the opendirectoryd mach services, and falls back to
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index d6a420a96988..546e63711853 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -223,6 +223,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags flags) {
     // Verify caller is not accidentally setting both mutually exclusive
     // policies.
     DCHECK(!(flags & MITIGATION_DYNAMIC_CODE_DISABLE_WITH_OPT_OUT));
+#ifdef NO_GOSTSSL
     PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
     policy.ProhibitDynamicCode = true;
 
@@ -231,6 +232,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags flags) {
         ERROR_ACCESS_DENIED != ::GetLastError()) {
       return false;
     }
+#endif // GOSTSSL
   }
 
   if (version < base::win::Version::WIN10)
@@ -253,6 +255,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags flags) {
 
   // Enable binary signing policies.
   if (flags & MITIGATION_FORCE_MS_SIGNED_BINS) {
+#ifdef NO_GOSTSSL
     PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
     // Allow only MS signed binaries.
     policy.MicrosoftSignedOnly = true;
@@ -265,6 +268,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags flags) {
         ERROR_ACCESS_DENIED != ::GetLastError()) {
       return false;
     }
+#endif // GOSTSSL
   }
 
   // Enable image load policies.
diff --git a/third_party/blink/renderer/core/frame/local_frame.cc b/third_party/blink/renderer/core/frame/local_frame.cc
index 4ceaa30497d2..c3557524c86d 100644
--- a/third_party/blink/renderer/core/frame/local_frame.cc
+++ b/third_party/blink/renderer/core/frame/local_frame.cc
@@ -38,6 +38,7 @@
 #include "base/unguessable_token.h"
 #include "mojo/public/cpp/bindings/self_owned_receiver.h"
 #include "mojo/public/cpp/system/message_pipe.h"
+#include "net/net_buildflags.h"
 #include "services/data_decoder/public/mojom/resource_snapshot_for_web_bundle.mojom-blink.h"
 #include "services/network/public/cpp/features.h"
 #include "services/network/public/mojom/content_security_policy.mojom-blink.h"
@@ -551,7 +552,9 @@ void LocalFrame::Trace(Visitor* visitor) const {
   visitor->Trace(raw_system_clipboard_);
   visitor->Trace(virtual_keyboard_overlay_changed_observers_);
   visitor->Trace(pause_handle_receivers_);
+#if BUILDFLAG(ENABLE_REPORTING)
   visitor->Trace(reporting_service_);
+#endif
 #if defined(OS_MAC)
   visitor->Trace(text_input_host_);
 #endif
@@ -2273,6 +2276,7 @@ const base::UnguessableToken& LocalFrame::GetAgentClusterId() const {
   return base::UnguessableToken::Null();
 }
 
+#if BUILDFLAG(ENABLE_REPORTING)
 mojom::blink::ReportingServiceProxy* LocalFrame::GetReportingService() {
   if (!reporting_service_.is_bound()) {
     GetBrowserInterfaceBroker().GetInterface(
@@ -2281,6 +2285,7 @@ mojom::blink::ReportingServiceProxy* LocalFrame::GetReportingService() {
   }
   return reporting_service_.get();
 }
+#endif
 
 // static
 void LocalFrame::NotifyUserActivation(
diff --git a/third_party/blink/renderer/core/frame/local_frame.h b/third_party/blink/renderer/core/frame/local_frame.h
index 7635e2c40c4a..bd974710f869 100644
--- a/third_party/blink/renderer/core/frame/local_frame.h
+++ b/third_party/blink/renderer/core/frame/local_frame.h
@@ -38,6 +38,7 @@
 #include "mojo/public/cpp/bindings/pending_associated_receiver.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/unique_receiver_set.h"
+#include "net/net_buildflags.h"
 #include "third_party/blink/public/common/frame/transient_allow_fullscreen.h"
 #include "third_party/blink/public/mojom/blob/blob_url_store.mojom-blink.h"
 #include "third_party/blink/public/mojom/frame/back_forward_cache_controller.mojom-blink.h"
@@ -521,9 +522,9 @@ class CORE_EXPORT LocalFrame final
   }
 
   SmoothScrollSequencer& GetSmoothScrollSequencer();
-
+#if BUILDFLAG(ENABLE_REPORTING)
   mojom::blink::ReportingServiceProxy* GetReportingService();
-
+#endif
   // Returns the frame host ptr. The interface returned is backed by an
   // associated interface with the legacy Chrome IPC channel.
   mojom::blink::LocalFrameHost& GetLocalFrameHostRemote() const;
@@ -903,9 +904,11 @@ class CORE_EXPORT LocalFrame final
   // const methods.
   //
   // LocalFrame can be reused by multiple ExecutionContext.
+#if BUILDFLAG(ENABLE_REPORTING)
   mutable HeapMojoRemote<mojom::blink::ReportingServiceProxy,
                          HeapMojoWrapperMode::kWithoutContextObserver>
       reporting_service_{nullptr};
+#endif
 
 #if defined(OS_MAC)
   // LocalFrame can be reused by multiple ExecutionContext.
diff --git a/third_party/blink/renderer/core/frame/reporting_context.cc b/third_party/blink/renderer/core/frame/reporting_context.cc
index 83b93cc83e12..366bec41b98e 100644
--- a/third_party/blink/renderer/core/frame/reporting_context.cc
+++ b/third_party/blink/renderer/core/frame/reporting_context.cc
@@ -4,6 +4,7 @@
 
 #include "third_party/blink/renderer/core/frame/reporting_context.h"
 
+#include "net/net_buildflags.h"
 #include "third_party/blink/public/common/browser_interface_broker_proxy.h"
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/task_type.h"
@@ -54,7 +55,9 @@ const char ReportingContext::kSupplementName[] = "ReportingContext";
 ReportingContext::ReportingContext(ExecutionContext& context)
     : Supplement<ExecutionContext>(context),
       execution_context_(context),
+#if BUILDFLAG(ENABLE_REPORTING)
       reporting_service_(&context),
+#endif
       receiver_(this, &context) {}
 
 // static
@@ -118,7 +121,9 @@ void ReportingContext::Trace(Visitor* visitor) const {
   visitor->Trace(observers_);
   visitor->Trace(report_buffer_);
   visitor->Trace(execution_context_);
+#if BUILDFLAG(ENABLE_REPORTING)
   visitor->Trace(reporting_service_);
+#endif
   visitor->Trace(receiver_);
   Supplement<ExecutionContext>::Trace(visitor);
 }
@@ -140,6 +145,7 @@ void ReportingContext::CountReport(Report* report) {
   UseCounter::Count(execution_context_, feature);
 }
 
+#if BUILDFLAG(ENABLE_REPORTING)
 const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
 ReportingContext::GetReportingService() const {
   if (!reporting_service_.is_bound()) {
@@ -149,6 +155,7 @@ ReportingContext::GetReportingService() const {
   }
   return reporting_service_;
 }
+#endif
 
 void ReportingContext::NotifyInternal(Report* report) {
   // Buffer the report.
@@ -171,6 +178,7 @@ void ReportingContext::NotifyInternal(Report* report) {
 
 void ReportingContext::SendToReportingAPI(Report* report,
                                           const String& endpoint) const {
+#if BUILDFLAG(ENABLE_REPORTING)
   const String& type = report->type();
   if (!(type == ReportType::kCSPViolation || type == ReportType::kDeprecation ||
         type == ReportType::kFeaturePolicyViolation ||
@@ -227,6 +235,7 @@ void ReportingContext::SendToReportingAPI(Report* report,
         "Document policy violation", body->sourceFile(), line_number,
         column_number);
   }
+#endif
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/frame/reporting_context.h b/third_party/blink/renderer/core/frame/reporting_context.h
index 51bee8be0e3f..d575e88b9a36 100644
--- a/third_party/blink/renderer/core/frame/reporting_context.h
+++ b/third_party/blink/renderer/core/frame/reporting_context.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_REPORTING_CONTEXT_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_REPORTING_CONTEXT_H_
 
+#include "net/net_buildflags.h"
 #include "third_party/blink/public/mojom/frame/reporting_observer.mojom-blink.h"
 #include "third_party/blink/public/mojom/reporting/reporting.mojom-blink.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -53,10 +54,10 @@ class CORE_EXPORT ReportingContext : public GarbageCollected<ReportingContext>,
  private:
   // Counts the use of a report type via UseCounter.
   void CountReport(Report*);
-
+#if BUILDFLAG(ENABLE_REPORTING)
   const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
   GetReportingService() const;
-
+#endif
   void NotifyInternal(Report* report);
   // Send |report| via the Reporting API to |endpoint|.
   void SendToReportingAPI(Report* report, const String& endpoint) const;
@@ -67,8 +68,10 @@ class CORE_EXPORT ReportingContext : public GarbageCollected<ReportingContext>,
 
   // This is declared mutable so that the service endpoint can be cached by
   // const methods.
+#if BUILDFLAG(ENABLE_REPORTING)
   mutable HeapMojoRemote<mojom::blink::ReportingServiceProxy>
       reporting_service_;
+#endif
 
   HeapMojoReceiver<mojom::blink::ReportingObserver, ReportingContext> receiver_;
 };
diff --git a/third_party/boringssl/BUILD.generated.gni b/third_party/boringssl/BUILD.generated.gni
index 740267ac8c2e..34786c612501 100644
--- a/third_party/boringssl/BUILD.generated.gni
+++ b/third_party/boringssl/BUILD.generated.gni
@@ -5,6 +5,8 @@
 # This file is created by generate_build_files.py. Do not edit manually.
 
 crypto_sources = [
+  "gostssl.cpp",
+  "msspi.cpp",
   "err_data.c",
   "src/crypto/asn1/a_bitstr.c",
   "src/crypto/asn1/a_bool.c",
-- 

